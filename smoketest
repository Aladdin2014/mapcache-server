#!/usr/bin/env node

var mongoose = require('mongoose')
  , async = require('async')
  , fs = require('fs-extra')
  , path = require('path')
  , exec = require('child_process').exec
  , config = require('./config.json')
  , api = require('./api');

var yargs = require("yargs")
  .usage("Usage: $0 [--shapefile <path to shapefile> --geotiff <path to geotiff> --geojson <path to geojson> --kmz <path to kmz> --mbtiles <path to mbtiles> --xyz <url to xyz tile source> --wms <url to wms source> --geojsonurl <url to geojson>]")
  .alias('d', 'debug')
  .help('help');

var argv = yargs.argv;

var mongodbConfig = config.server.mongodb;

var mongoUri = "mongodb://" + mongodbConfig.host + "/" + mongodbConfig.db;
mongoose.connect(mongoUri, {server: {poolSize: mongodbConfig.poolSize}}, function(err) {
  if (err) {
    console.log('Error connecting to mongo database, please make sure mongodb is running...');
    throw err;
  }
});

mongoose.set('debug', argv.d);

console.log('Mongo is set up correctly');

async.series([
  xyz
], function(err, results) {
  if (err) {
    console.log('Not all tests passed', err);
  }
  if (results) {
    for (var i = 0; i < results.length; i++) {
      if (Array.isArray(results[i])) {
        for (var j = 0; j < results[i].length; j++) {
          console.log(results[i][j]);
        }
      } else {
        console.log(results[i]);
      }
    }
  }
  process.exit();
});

var sourceId;
var cache;


function xyz(callback) {
  if (argv.xyz) {

    var sourceName = 'Smoketest XYZ Source';
    var cacheName = 'Smoketest XYZ Cache';


    var tests = [
      function(callback) {
        console.log("Testing creating an XYZ source.");

        var args = ['--url', argv.xyz, '--name', "'"+sourceName+"'", '--type', 'xyz'];
        launchCommand('createSource', args, function() {

          new api.Source().getAll({name: sourceName}, function(err, sources) {
            if (sources && sources[0] && sources[0].name == sourceName) {
              sourceId = sources[0].id;
              callback(null, 'Create XYZ Source: XYZ source was created');
            } else {
              callback(new Error("XYZ Source was not created"), 'FAILURE: XYZ Source was not created');
            }
          });
        });
      },
      function(callback) {
        console.log("Testing creating a cache from an XYZ source.");

        var args = ['--source', sourceId, '--name', "'"+cacheName+"'", '--format', 'xyz', '-w', -104.826909, '-e', -104.623662, '-s', 39.585987, '-n', 39.740334, '--maxZoom', 14, '--minZoom', 0];
        launchCommand('createCache', args, function() {

          new api.Cache().getAll({name: cacheName}, function(err, caches) {
            if (caches && caches[0] && caches[0].name == cacheName) {
              cache = caches[0];
              callback(null, 'Create XYZ cache: XYZ cache was created');
            } else {
              callback(new Error("XYZ cache was not created"), 'FAILURE: XYZ cache was not created');
            }
          });
        });
      }
    ];

    var cacheTypes = config.sourceCacheTypes['xyz'];
    for (var i = 0; i < cacheTypes.length; i++) {
      var item = cacheTypes[i];
      tests.push(generateCacheFormat(item));
    }

    // tests.push(
    //   function(callback) {
    //     console.log("Testing deleting an XYZ source.");
    //     var args = ['--id', sourceId];
    //     launchCommand('deleteSource', args, function() {
    //
    //       new api.Source().getAll({name: sourceName}, function(err, sources) {
    //         if (sources && sources.length == 0) {
    //           // ensure the directory is gone too
    //           var exists = fs.existsSync(path.join(config.server.sourceDirectory.path, sourceId));
    //           if (!exists) {
    //             callback(null, 'Delete XYZ Source: XYZ source was deleted');
    //           } else {
    //             callback(new Error("XYZ Source was not deleted"), 'FAILURE: XYZ Source directory was not deleted');
    //           }
    //         } else {
    //           callback(new Error("XYZ Source was not deleted"), 'FAILURE: XYZ Source was not deleted');
    //         }
    //       });
    //     });
    //   }
    // );

    async.series(tests, callback);
  }
}

function generateCacheFormat(item) {
  return function(callback) {
    if (item.required) {
      // should already exist
      return callback(null, 'Cache format ' + item.type + ' should already exist.');
    } else {
      var args = ['--cache', cache.id, '--format', item.type];
      launchCommand('generateFormat', args, function() {

        new api.Cache().getAll({name: cache.name}, function(err, caches) {
          if (caches && caches[0] && caches[0].name == cache.name) {
            cache = caches[0];
            if (cache.formats[item.type] && cache.formats[item.type].size) {
              return callback(null, 'XYZ Cache format ' + item.type + ' was created.');
            } else {
              callback(new Error("XYZ cache format "+ item.type + " was not created"), "FAILURE: XYZ cache format "+ item.type + " was not created");
            }
          } else {
            callback(new Error("XYZ cache was not created"), 'FAILURE: XYZ cache was not created');
          }
        });
      });
    }
  }
}

function launchCommand(command, args, callback) {
  console.log('running ' + './mapcache ' + command + ' ' + args.join(' '));
  exec(
    './mapcache ' + command + ' ' + args.join(' '),
    function(error, stdout, stderr) {
      console.log('done running ' + './mapcache ' + command + ' ' + args.join(' '));
      callback(error);
    }
  );
}
