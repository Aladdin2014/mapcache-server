#!/usr/bin/env node

var api = require('./api')
  , mongoose = require('mongoose')
  , fs = require('fs-extra')
  , path = require('path')
  , config = require('./config.json');

var optimist = require("optimist")
  .usage("Usage: $0 -o [operation] -f [file] -u [url] -t [type] -n [name] -i [id] -s [style file]")
  .demand('o')
  .alias('d', 'debug')
  .alias('o', 'operation')
  .alias('f', 'file')
  .alias('n', 'name')
  .alias('i', 'id')
  .alias('t', 'type')
  .alias('t', 'format')
  .alias('u', 'url')
  .alias('s', 'style')
  .describe('o', 'mapcache operation to run');
  // .default('o', 4242);

var argv = optimist.argv;
if (argv.h || argv.help) return optimist.showHelp();

var mongodbConfig = config.server.mongodb;

var mongoUri = "mongodb://" + mongodbConfig.host + "/" + mongodbConfig.db;
mongoose.connect(mongoUri, {server: {poolSize: mongodbConfig.poolSize}}, function(err) {
  if (err) {
    console.log('Error connecting to mongo database, please make sure mongodb is running...');
    throw err;
  }
});

mongoose.set('debug', argv.d);

var operations = {
};

operations.status = function() {
  new api.Server().getInfo(function(err, server) {
    if (err) return console.error('Error getting server status: ', err);
    console.log('\nServer status: \n\tTotal Server Bytes Available: %s\n\tTotal Server Bytes Used: %s\n\tmapcache Bytes Available: %s\n\tmapcache Bytes Used: %s\n\tMaximum Cache Size: %s', server.serverTotal, server.serverFree, server.total, server.used, server.maximumCacheSize);
    process.exit();
  });
}

operations.createSource = function() {
  var source = {
    name: argv.name,
    format: argv.format
  };
  if (argv.f) {
    fs.copy(argv.f, '/tmp/' + path.basename(argv.f), function(err) {
      new api.Source().import(source, {path: '/tmp/' + path.basename(argv.f)}, function(err, source) {
        setTimeout(sourceTimerFunction, 0, source);
      });
    });
  } else {
    source.url = argv.u;
    new api.Source().create(source, function(err, source) {
      setTimeout(sourceTimerFunction, 0, source);
    });
  }
}

operations.getSourceById = function() {
  new api.Source().getById(argv.id, function(err, source) {
    console.log('Source:\n\tName:%s\n\tFormat:%s\n\tID:%s\n\tStatus:%s', source.name, source.format, source._id, source.status.message);
    process.exit();
  });
}

operations.getAllSources = function() {
  new api.Source().getAll({}, function(err, sources) {
    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      console.log('Source:\n\tName:%s\n\tFormat:%s\n\tID:%s\n\tStatus:%s', source.name, source.format, source._id, source.status.message);
    }
    process.exit();
  });
}

operations.deleteSourceById = function() {
  new api.Source().getById(argv.id, function(err, source) {
    new api.Source().delete(source, function(err, source) {
      console.log('Deleted Source:\n\tName:%s\n\tFormat:%s\n\tID:%s\n\tStatus:%s', source.name, source.format, source._id, source.status.message);
      process.exit();
    });
  });
}

function sourceTimerFunction(source) {
  new api.Source().getById(source._id, function(err, source) {
    if (!source.status.complete) {
      console.log('Source is being created:\n\tName:%s\n\tFormat:%s\n\tID:%s\n\tStatus:%s', source.name, source.format, source._id, source.status.message);
      setTimeout(sourceTimerFunction, 5000, source);
    } else {
      console.log('Source was created:\n\tName:%s\n\tFormat:%s\n\tID:%s\n\tStatus:%s', source.name, source.format, source._id, source.status.message);
      process.exit();
    }
  });
}

function main() {
  if (!operations[argv.o]) {
    console.log('No operation [%s] exists.\n\nValid operations are:', argv.o);
    for (var key in operations) {
      console.log('Operation: %s', key);
    }
    process.exit();
  }

  operations[argv.o]();
}

main();
